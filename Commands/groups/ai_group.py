import datetime
import io
import time
import aiohttp
from Commands.utils.button_helper import CharacterView, DeleteButton
from Commands.utils.help_dropdown import GenericDropdown, GenericDropdownView
import discord, SQL.helper
import replicate
from discord.ext import commands
from typing import Optional
from discord import app_commands, Embed
from io import BytesIO
from diffusers import DiffusionPipeline
from diffusers.utils import load_image

# import flux, flux.src
import base64
import os, sys

# Add the "flux/src" directory to Python path
# flux_src = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'flux', 'src'))
# if flux_src not in sys.path:
#     sys.path.insert(0, flux_src)

# from flux import demo_gr


# AI_GENERATION_MAX = 10


@discord.app_commands.allowed_installs(guilds=True, users=True)
@discord.app_commands.allowed_contexts(guilds=True, dms=True, private_channels=True)
class AIGroup(app_commands.Group):
    image = app_commands.Group(name="image", description="Image commands")
    char = app_commands.Group(name="char", description="Character commands")

    def __init__(self, cog: commands.Cog):
        super().__init__(name="ai", description="AI commands group")
        self.cog = cog
        self._db = SQL.helper.Helper()

    # After defining all commands, set allowed contexts
    async def set_contexts(self, bot: commands.bot):
        for command in self.walk_commands():
            command.allowed_contexts = app_commands.allowed_contexts(
                guilds=True, dms=True, private_channels=True
            )
            # await bot.tree.sync()  # Push the change to Discord

    @discord.app_commands.allowed_installs(guilds=True, users=True)
    @discord.app_commands.allowed_contexts(guilds=True, dms=True, private_channels=True)
    @image.command(name="gen", description="Generate an image using AI")
    async def gen(self, interaction: discord.Interaction, prompt: str):
        await interaction.response.defer()
        gens = self._db.get_gen(interaction.user.id)

        # if gens < AI_GENERATION_MAX + 10:
        try:
            img_stream = await self.cog.generate_image(prompt)

            file = discord.File(img_stream, filename="image.png")
            embed = discord.Embed(title=f"Image #{gens}")
            embed.set_image(url="attachment://image.png")
            self._db.save_gen(interaction.user.id, gens + 1)

            embed.set_footer(icon_url=interaction.user.avatar.url, text=f"Generated by {interaction.user.display_name}, {datetime.datetime.now().strftime("%B %#d, %Y, %#I:%M %p")}")

            await interaction.followup.send(embed=embed, file=file)
        except Exception as e:  
            await interaction.followup.send(f"‚ùå Failed to generate image. {e}")
        # elif gens >= AI_GENERATION_MAX + 10:
        #     return await interaction.followup.send(
        #         f"‚ùå You have reached the max limit of {AI_GENERATION_MAX + 10} generations for /ai image gen."
        #     )
        # else:
        #     print(f"Unexpected gens value: {gens}")
        #     return

    @image.command(name="edit", description="Edit an image using AI")
    async def edit(
        self, interaction: discord.Interaction, image: discord.Attachment, prompt: str
    ):
        await interaction.response.defer()
        gens = self._db.get_gen(interaction.user.id)

        # if gens < AI_GENERATION_MAX:
        try:
            image_url = await self.cog.generate_image_to_image(image.url, prompt)
            # Download image to BytesIO
            async with aiohttp.ClientSession() as session:
                async with session.get(image_url) as resp:
                    if resp.status != 200:
                        raise Exception("Failed to download generated image")
                    data = io.BytesIO(await resp.read())
                    data.seek(0)
            file = discord.File(data, filename="image.png")
            embed = discord.Embed(title=f"Image #{gens}")
            embed.set_image(url="attachment://image.png")
            embed.set_thumbnail(url=image.url)
            
            self._db.save_gen(interaction.user.id, gens + 1)

            embed.set_footer(icon_url=interaction.user.avatar.url, text=f"Generated by {interaction.user.display_name}, {datetime.datetime.now().strftime("%B %#d, %Y, %#I:%M %p")}")

            await interaction.followup.send(embed=embed, file=file)
        except Exception as e:
            await interaction.followup.send(f"‚ùå Failed to generate image. {e}")
        # elif gens >= AI_GENERATION_MAX:
        #     return await interaction.followup.send(
        #         f"‚ùå You have reached the max limit of {AI_GENERATION_MAX} generations for /ai image edit."
        #     )
        # else:
        #     print(f"Unexpected gens value: {gens}")
        #     return

    # @app_commands.command(
    #     name="audio", description="Generate audio for a video using AI"
    # )
    # async def audio(
    #     self,
    #     interaction: discord.Interaction,
    #     prompt: str = None,
    # ):
    #     await interaction.response.defer()
    #     gens = self._db.get_gen(interaction.user.id)

    #     if gens < AI_GENERATION_MAX:
    #         try:

    #             input = {
    #                 "prompt": prompt or "",
    #                 "model_version": "large",
    #                 "save_spectrogram": False,
    #             }
    #             prediction = replicate.predictions.create(
    #                 version="eebfed4a1749bb1172f005f71fac5a1e0377502ec149c9d02b56ac1de3aa9f07",
    #                 input=input,
    #             )
    #             print(prediction)
    #             while prediction.status not in ["succeeded", "failed", "canceled"]:
    #                 time.sleep(1)
    #                 prediction = replicate.predictions.get(prediction.id)

    #             if prediction.status != "succeeded":
    #                 prediction.cancel()
    #                 raise Exception(f"‚ùå Unexpected output type from Replicate")
    #             print(prediction.output["wav"])
    #             result_url = prediction.output["wav"]
    #             if not result_url:
    #                 return await interaction.followup.send(
    #                     "‚ùå Invalid result from audio generation."
    #                 )
    #             # Step 1: Download the image
    #             data = self.cog.download_with_retries(result_url)

    #             # Step 2: Wrap image bytes into BytesIO
    #             audio_bytes = BytesIO(data)
    #             audio_bytes.seek(0)

    #             # # Download the file from result_url
    #             # async with aiohttp.ClientSession() as session:
    #             #     async with session.get(result_url) as resp:
    #             #         if resp.status != 200:
    #             #             return await interaction.followup.send("‚ùå Failed to download generated audio.")
    #             #         audio_bytes = await resp.read()

    #             # audio_stream = io.BytesIO(audio_bytes)
    #             # audio_stream.seek(0)
    #             file = discord.File(audio_bytes, filename="audio.mp3")
    #             embed = discord.Embed()
    #             self._db.save_gen(interaction.user.id, gens + 1)
    #             embed.set_footer(
    #                 text=f"Generated by {interaction.user.name} | Generations: {gens + 1}/{AI_GENERATION_MAX}"
    #             )
    #             await interaction.followup.send(embed=embed, file=file)
    #         except Exception as e:
    #             await interaction.followup.send(f"‚ùå Failed to generate audio. {e}")
    #     elif gens >= AI_GENERATION_MAX:
    #         return await interaction.followup.send(
    #             f"‚ùå You have reached the max limit of {AI_GENERATION_MAX} generations."
    #         )
    #     else:
    #         print(f"Unexpected gens value: {gens}")
    #         return

    # @image.command(name="3d", description="Generate a 3d video from an image using AI")
    # async def image3d(
    #     self, interaction: discord.Interaction, image: discord.Attachment
    # ):
    #     await interaction.response.defer()
    #     gens = self._db.get_gen(interaction.user.id)

    #     if gens < AI_GENERATION_MAX:
    #         try:

    #             prediction = replicate.predictions.create(
    #                 version="e8f6c45206993f297372f5436b90350817bd9b4a0d52d2a76df50c1c8afa2b3c",
    #                 input={
    #                     "images": [image.url],
    #                     "generate_color": True,
    #                     "generate_model": False,
    #                     "randomize_seed": True,
    #                     "generate_normal": False,
    #                     "save_gaussian_ply": False,
    #                 },
    #             )
    #             print(prediction)
    #             while prediction.status not in ["succeeded", "failed", "canceled"]:
    #                 time.sleep(1)
    #                 prediction = replicate.predictions.get(prediction.id)

    #             if prediction.status != "succeeded":
    #                 prediction.cancel()
    #                 raise Exception(f"‚ùå Unexpected output type from Replicate")
    #             print(prediction.output["color_video"])
    #             result_url = prediction.output["color_video"]
    #             if not result_url:
    #                 return await interaction.followup.send(
    #                     "‚ùå Invalid result from video generation."
    #                 )
    #             # Step 1: Download the image
    #             data = self.cog.download_with_retries(result_url)

    #             # Step 2: Wrap image bytes into BytesIO
    #             bytes = BytesIO(data)
    #             bytes.seek(0)

    #             file = discord.File(bytes, "video.mp4")
    #             embed = discord.Embed()
    #             self._db.save_gen(interaction.user.id, gens + 1)
    #             embed.set_footer(
    #                 text=f"Generated by {interaction.user.name} | Generations: {gens + 1}/{AI_GENERATION_MAX}"
    #             )

    #             await interaction.followup.send(embed=embed, file=file)
    #         except Exception as e:
    #             await interaction.followup.send(f"‚ùå Failed to generate video. {e}")
    #     elif gens >= AI_GENERATION_MAX:
    #         return await interaction.followup.send(
    #             f"‚ùå You have reached the max limit of {AI_GENERATION_MAX} generations."
    #         )
    #     else:
    #         print(f"Unexpected gens value: {gens}")
    #         return

    @app_commands.command(name="text", description="Generate text using AI")
    async def text(
        self,
        interaction: discord.Interaction,
        prompt: str,
        image: discord.Attachment = None,
    ):
        await interaction.response.defer()
        try:
            image_data = await self.cog.encode_image(image.url) if image else None
            result = await self.cog.generate_text(prompt=prompt, image_url=image_data)
        except Exception as e:
            result = f"‚ùå Error: {e}"

        # Build embed
        embed = Embed(
            description=result[:4000],  # Embed description max is 4096 chars
            # title=prompt[:256],  # Embed title max is 256 chars
        )

        if image:
            embed.set_image(url=image.url)
            embed.set_footer(text=f"Image sent by {interaction.user.name}")

        await interaction.followup.send(embed=embed)

    # @app_commands.command(
    #     name="random", description="Generate a random image with FLUX.1"
    # )
    # async def random_image(self, interaction: discord.Interaction):
    #     await interaction.response.defer()

    #     gens = self._db.get_gen(interaction.user.id)

    #     if gens < AI_GENERATION_MAX:
    #         try:
    #             prompt = await self.cog.generate_text(
    #                 "generate a random prompt for an AI image generator"
    #             )

    #             img_stream = await self.cog.generate_image(prompt)
    #             file = discord.File(img_stream, filename="random_image.png")
    #             embed = discord.Embed(title="Random Image", description=prompt)
    #             embed.set_image(url="attachment://random_image.png")
    #             embed.set_footer(
    #                 text=f"Generated by {interaction.user.name} | Generations: {gens + 1}/{AI_GENERATION_MAX}"
    #             )
    #             await interaction.followup.send(embed=embed, file=file)
    #             self._db.save_gen(interaction.user.id, gens + 1)
    #         except Exception as e:
    #             await print(f"Failed to generate random image: {e}")
    #     elif gens >= AI_GENERATION_MAX:
    #         return await interaction.followup.send(
    #             f"‚ùå You have reached the max limit of {AI_GENERATION_MAX} generations."
    #         )
    #     else:
    #         print(f"Unexpected gens value: {gens}")
    #         return

    # @app_commands.command(name="reset", description="Reset your AI generation count.")
    # async def reset_generation(self, interaction: discord.Interaction):
    #     await interaction.response.defer()
    #     if self._db.get_money(interaction.user.id) < 1000000000:
    #         return await interaction.followup.send(
    #             "‚ùå You need a billion dollars to reset your AI generation count."
    #         )
    #     else:
    #         self._db.save_gen(interaction.user.id, 0)
    #         await interaction.followup.send(
    #             "‚úÖ Your AI generation count has been reset to 0."
    #         )

    @char.command(
        name="list", description="See the list of AI characters you've created."
    )
    async def list_characters(self, interaction: discord.Interaction):
        await interaction.response.defer()

        all_characters = self._db.get_girl()
        all_characters.sort()
        if not all_characters:
            await interaction.followup.send(
                "No characters available. Use `/ai create` to get started!"
            )
            return

        async def on_select(inter: discord.Interaction, values: list[str]):
            index = int(values[0])
            character_name, encoded_info, image_url = all_characters[index]

            try:
                decoded_info = base64.b64decode(encoded_info).decode("utf-8")
            except Exception:
                decoded_info = "*Failed to decode character info.*"

            embed = discord.Embed(
                title=f"{index + 1}. {character_name.title()}",
                description=(
                    decoded_info
                    if len(decoded_info) <= 4096
                    else decoded_info[:4093] + "..."
                ),
                color=discord.Color.from_rgb(120, 220, 212),
            )
            print(f"Image URL: {image_url}")

            if image_url:
                embed.set_thumbnail(url=image_url)
            new_view = discord.ui.View()
            new_view.add_item(
                GenericDropdown(
                    options=dropdown_options,
                    placeholder="Select a character to view details...",
                    on_select=on_select,
                )
            )
            new_view.add_item(
                DeleteButton(character_name, interaction.user.id, self._db)
            )
            await inter.response.edit_message(embed=embed, view=new_view)

        dropdown_options = [
            discord.SelectOption(label=f"{i + 1}. {girl[0]}", value=str(i))
            for i, girl in enumerate(all_characters[:25])
        ]

        view = GenericDropdownView(
            options=dropdown_options,
            placeholder="Select a character to view details...",
            on_select=on_select,
        )
        if len(all_characters) > 25:
            description = "\n".join(
                f"**{i+1}.** {name.title()}"
                for i, (name, _, _) in enumerate(all_characters)
            )
        else:
            description = "Select a character from the dropdown below to view details."
        embed = discord.Embed(
            title=f"{interaction.user.name}'s characters ({len(all_characters)})",
            description=description,
            color=discord.Color.from_rgb(120, 220, 212),
        )
        await interaction.followup.send(embed=embed, view=view)

    @char.command(name="create", description=f"Create a new AI character.")
    async def create_character(
        self,
        interaction: discord.Interaction,
        info: str = None,
        name: str = None,
        greeting: str = None,
        img: discord.Attachment = None,
    ):
        await interaction.response.defer()
        # embed.set_image(url=image_url)
        if img is None:
            image_url = ""
        else:
            image_url = img.url

        character_name = name or "A Character"

        character_info = info or "No info provided."

        character_greeting = greeting or None

        embed = discord.Embed(
            title=character_name,
            description=info or character_greeting,
        )
        if image_url is not None:
            embed.set_image(url=image_url)

        self._db.save_girl(
            character_name,
            base64.b64encode(character_info.encode()).decode(),
            image_url,
        )

        await interaction.edit_original_response(embed=embed)

    @char.command(
        name="update", description="Update an AI character's name, info, or image."
    )
    async def update_character(
        self,
        interaction: discord.Interaction,
        name: str,
        new_name: Optional[str] = None,
        new_info: Optional[str] = None,
        new_image: Optional[discord.Attachment] = None,
    ):
        await interaction.response.defer()

        # Fetch all characters
        all_characters = self._db.get_girl()
        if not all_characters:
            await interaction.followup.send(
                "You haven't created any AI characters yet."
            )
            return

        # Find character by old name (case-insensitive partial match)
        matched_char = next(
            (c for c in all_characters if name.lower() in c[0].lower()), None
        )
        if not matched_char:
            await interaction.followup.send(f"No character found matching **{name}**.")
            return

        current_name, current_info_b64, current_image_url = matched_char
        updated_name = new_name or current_name
        raw_info = (
            new_info.replace("\\n", "\n")
            if new_info
            else base64.b64decode(current_info_b64).decode("utf-8")
        )
        updated_info = base64.b64encode(raw_info.encode("utf-8")).decode("utf-8")
        updated_image_url = new_image.url if new_image else current_image_url

        # Delete the old character and insert the updated one
        self._db.delete_girl(current_name)
        self._db.save_girl(
            updated_name, updated_info, updated_image_url
        )

        await interaction.followup.send(
            f"‚úÖ Updated character **{current_name}**.\n"
            f"New name: **{updated_name}**\n"
            f"New image: {'‚úÖ Updated' if new_image else '‚ùå Unchanged'}\n"
            f"New info: {'‚úÖ Updated' if new_info else '‚ùå Unchanged'}"
        )

    # @char.command(
    #     name="info", description="Get the info/backstory of an AI character."
    # )
    # async def get_character_info(self, interaction: discord.Interaction, index: int):
    #     await interaction.response.defer()

    #     all_characters = self.cog._db.get_girl(interaction.user.id)
    #     if not all_characters:
    #         await interaction.followup.send(
    #             "You haven't created any AI characters yet."
    #         )
    #         return

    #     # Validate index (user input starts at 1, Python list is 0-based)
    #     if index < 1 or index > len(all_characters):
    #         await interaction.followup.send(
    #             f"Invalid index. You have {len(all_characters)} character(s)."
    #         )
    #         return

    #     character_name, encoded_info, image_url = all_characters[index - 1]
    #     print(f"Image URL: {image_url}")

    #     try:
    #         decoded_info = base64.b64decode(encoded_info).decode("utf-8")
    #     except Exception:
    #         decoded_info = "*Failed to decode character info.*"

    #     embed = discord.Embed(
    #         title=f"üìñ Info: {character_name}",
    #         description=(
    #             decoded_info
    #             if len(decoded_info) <= 4096
    #             else decoded_info[:4093] + "..."
    #         ),
    #     )

    #     if image_url:
    #         embed.set_thumbnail(url=image_url)

    #     await interaction.followup.send(embed=embed)

    @char.command(name="text", description="Talk to one of your AI characters.")
    async def talk_to_character(
        self,
        interaction: discord.Interaction,
        name: str,
        prompt: str,
        image: discord.Attachment = None,
    ):
        await interaction.response.defer()

        # Get all characters for the user
        all_characters = self._db.get_girl()
        if not all_characters:
            await interaction.followup.send(
                "No characters available. Try `/ai char create` first."
            )
            return

        # Find the character by name (case-insensitive partial match)
        matched_char = next(
            (c for c in all_characters if name.lower() in c[0].lower()), None
        )
        if not matched_char:
            await interaction.followup.send(
                f"No character found matching **{name}**. Use `/ai char list` to see your characters."
            )
            return

        # Decode the stored info
        character_name = matched_char[0]
        info = base64.b64decode(matched_char[1]).decode("utf-8")
        character_image_url = matched_char[2]
        # print(
        #     f"talk name: {name}\ntalk info: {info}\ntalk img: {character_image_url}\n"
        # )

        # User's optional image URL
        user_image_url = image.url if image else None
        image_data = (
            await self.cog.encode_image(user_image_url) if user_image_url else None
        )
        # print(f"image_data: '{image_data}'\n")

        # Generate AI response
        reply = await self.cog.generate_text_char(
            f"prompt: '{prompt}' "
            f"this is your info: {info}. generate a unique reply in character. "
            f"Do not repeat the user‚Äôs words, and return only your response."
            f"Use the character's name, {character_name}, in your response. Do not use quotation marks.",
            image_data if image_data else None,
        )
        print(f"reply: \n{reply}\n")
        # Truncate reply if too long
        if len(reply) > 4096:
            reply = reply[:4093] + "..."

        # Build embed
        embed = discord.Embed(
            title=character_name,
            description=reply,
            color=discord.Color.from_rgb(120, 220, 212),
        )
        embed.set_image(url=character_image_url)
        if user_image_url:
            embed.set_thumbnail(url=user_image_url)
        await interaction.followup.send(embed=embed)
